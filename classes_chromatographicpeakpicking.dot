digraph "classes_chromatographicpeakpicking" {
rankdir=BT
charset="utf-8"
"src.chromatographicpeakpicking.analysis.baseline.aals.AALSConfig" [color="black", fontcolor="black", label=<{AALSConfig|<br ALIGN="LEFT"/>|}>, shape="record", style="solid"];
"src.chromatographicpeakpicking.analysis.baseline.aals.AALSCorrector" [color="black", fontcolor="black", label=<{AALSCorrector|config<br ALIGN="LEFT"/>|configure(config: AALSConfig): ValidationResult<br ALIGN="LEFT"/>correct(chromatogram: Chromatogram): Chromatogram<br ALIGN="LEFT"/>get_metadata(): ConfigMetadata<br ALIGN="LEFT"/>validate(chromatogram: Chromatogram): None<br ALIGN="LEFT"/>validate_config(config: AALSConfig): ValidationResult<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"src.chromatographicpeakpicking.analysis.base.analysis_context.AnalysisContext" [color="black", fontcolor="black", label=<{AnalysisContext|<br ALIGN="LEFT"/>|register_analyzer(name: str, analyzer: Analyzer): None<br ALIGN="LEFT"/>run_analysis(name: str, data: Any): AnalysisResult<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"src.chromatographicpeakpicking.core.protocols.observable.AnalysisEvent" [color="black", fontcolor="black", label=<{AnalysisEvent|message : str<br ALIGN="LEFT"/>progress : float<br ALIGN="LEFT"/>stage : str<br ALIGN="LEFT"/>|}>, shape="record", style="solid"];
"src.chromatographicpeakpicking.infrastructure.logging.analysis_logger.AnalysisLogger" [color="black", fontcolor="black", label=<{AnalysisLogger|level : int<br ALIGN="LEFT"/>log_path : Path<br ALIGN="LEFT"/>|get_session_id(): str<br ALIGN="LEFT"/>log_analysis_end(results: Dict[str, Any]): None<br ALIGN="LEFT"/>log_analysis_start(parameters: Dict[str, Any]): None<br ALIGN="LEFT"/>log_analysis_step(step: str, metrics: Dict[str, Any]): None<br ALIGN="LEFT"/>log_error(error: Exception, context: Dict[str, Any]): None<br ALIGN="LEFT"/>log_performance_metrics(metrics: Dict[str, Any]): None<br ALIGN="LEFT"/>log_validation_results(results: Dict[str, Any]): None<br ALIGN="LEFT"/>log_warning(message: str, context: Dict[str, Any]): None<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"src.chromatographicpeakpicking.pipeline.builders.pipeline_builder.AnalysisPipeline" [color="black", fontcolor="black", label=<{AnalysisPipeline|baseline_corrector : Optional[BaselineCorrector]<br ALIGN="LEFT"/>observers : List[ProgressObserver]<br ALIGN="LEFT"/>peak_detector : Optional[PeakDetector]<br ALIGN="LEFT"/>|process(chromatogram: Chromatogram): Chromatogram<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"src.chromatographicpeakpicking.analysis.protocols.analyzer.AnalysisResult" [color="black", fontcolor="black", label=<{AnalysisResult|execution_time : float<br ALIGN="LEFT"/>metadata : Dict[str, Any]<br ALIGN="LEFT"/>result : Output<br ALIGN="LEFT"/>|}>, shape="record", style="solid"];
"src.chromatographicpeakpicking.core.protocols.analyzable.Analyzable" [color="black", fontcolor="black", label=<{Analyzable|<br ALIGN="LEFT"/>|analyze(data: Any): Any<br ALIGN="LEFT"/>validate(data: Any): bool<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"src.chromatographicpeakpicking.analysis.protocols.analyzer.Analyzer" [color="black", fontcolor="black", label=<{Analyzer|<br ALIGN="LEFT"/>|<I>analyze</I>(data: Input): AnalysisResult[Output]<br ALIGN="LEFT"/><I>validate</I>(data: Input): bool<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"src.chromatographicpeakpicking.core.factories.analyzer_factory.AnalyzerFactory" [color="black", fontcolor="black", label=<{AnalyzerFactory|<br ALIGN="LEFT"/>|create(name: str): Analyzable<br ALIGN="LEFT"/>register(name: str, analyzer_class: Type[Analyzable]): None<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"src.chromatographicpeakpicking.core.types.config.BaseConfig" [color="black", fontcolor="black", label=<{BaseConfig|metadata<br ALIGN="LEFT"/>parameters : Dict[str, Any]<br ALIGN="LEFT"/>|}>, shape="record", style="solid"];
"src.chromatographicpeakpicking.infrastructure.persistence.base_repository.BaseRepository" [color="black", fontcolor="black", label=<{BaseRepository|<br ALIGN="LEFT"/>|<I>delete</I>(entity_id)<br ALIGN="LEFT"/><I>get</I>(entity_id)<br ALIGN="LEFT"/><I>get_all</I>()<br ALIGN="LEFT"/><I>save</I>(entity)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"src.chromatographicpeakpicking.analysis.chromatogram.baseline_analyzer.BaselineAnalysisResult" [color="black", fontcolor="black", label=<{BaselineAnalysisResult|baseline : ndarray<br ALIGN="LEFT"/>metrics : Dict[str, float]<br ALIGN="LEFT"/>|}>, shape="record", style="solid"];
"src.chromatographicpeakpicking.analysis.chromatogram.baseline_analyzer.BaselineAnalyzer" [color="black", fontcolor="black", label=<{BaselineAnalyzer|<br ALIGN="LEFT"/>|analyze(data: Chromatogram): AnalysisResult[BaselineAnalysisResult]<br ALIGN="LEFT"/>validate(data: Chromatogram): bool<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"src.chromatographicpeakpicking.core.protocols.correctable.BaselineCorrector" [color="black", fontcolor="black", label=<{BaselineCorrector|<br ALIGN="LEFT"/>|correct(chromatogram: Chromatogram): Chromatogram<br ALIGN="LEFT"/>validate(chromatogram: Chromatogram): None<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"src.chromatographicpeakpicking.core.domain.building_block.BuildingBlock" [color="black", fontcolor="black", label=<{BuildingBlock|formula : Optional[str]<br ALIGN="LEFT"/>id : str<br ALIGN="LEFT"/>mass : float<br ALIGN="LEFT"/>metadata : Dict[str, Any]<br ALIGN="LEFT"/>name : str<br ALIGN="LEFT"/>properties : Optional[Dict[str, Any]]<br ALIGN="LEFT"/>smiles : Optional[str]<br ALIGN="LEFT"/>|with_metadata(): 'BuildingBlock'<br ALIGN="LEFT"/>with_properties(): 'BuildingBlock'<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"src.chromatographicpeakpicking.io.formats.csv_format.CSVFormatHandler" [color="black", fontcolor="black", label=<{CSVFormatHandler|<br ALIGN="LEFT"/>|read(path: Path): Dict[str, Any]<br ALIGN="LEFT"/>validate(path: Path): bool<br ALIGN="LEFT"/>write(data: Dict[str, Any], path: Path): None<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"src.chromatographicpeakpicking.core.domain.chromatogram.Chromatogram" [color="black", fontcolor="black", label=<{Chromatogram|baseline : Optional[np.ndarray]<br ALIGN="LEFT"/>building_blocks : List[BuildingBlock]<br ALIGN="LEFT"/>duration<br ALIGN="LEFT"/>id : str<br ALIGN="LEFT"/>intensity : ndarray<br ALIGN="LEFT"/>length<br ALIGN="LEFT"/>metadata : Dict[str, Any]<br ALIGN="LEFT"/>metrics : Optional[Any]<br ALIGN="LEFT"/>noise_level : Optional[float]<br ALIGN="LEFT"/>num_peaks<br ALIGN="LEFT"/>peaks : List[Peak]<br ALIGN="LEFT"/>picked_peak : Optional[Peak]<br ALIGN="LEFT"/>search_mask : Optional[np.ndarray]<br ALIGN="LEFT"/>time : ndarray<br ALIGN="LEFT"/>y_corrected : Optional[np.ndarray]<br ALIGN="LEFT"/>|get_corrected_intensity(): np.ndarray<br ALIGN="LEFT"/>get_intensity_range(): tuple[float, float]<br ALIGN="LEFT"/>get_peaks_in_range(start_time: float, end_time: float): List[Peak]<br ALIGN="LEFT"/>get_signal_at_time(t: float): Optional[float]<br ALIGN="LEFT"/>get_time_range(): tuple[float, float]<br ALIGN="LEFT"/>normalize(method: str): 'Chromatogram'<br ALIGN="LEFT"/>resample(num_points: int): 'Chromatogram'<br ALIGN="LEFT"/>slice(start_time: float, end_time: float): 'Chromatogram'<br ALIGN="LEFT"/>smooth(window_length: int, polyorder: int): 'Chromatogram'<br ALIGN="LEFT"/>with_baseline(baseline: np.ndarray): 'Chromatogram'<br ALIGN="LEFT"/>with_building_blocks(blocks: List[BuildingBlock]): 'Chromatogram'<br ALIGN="LEFT"/>with_metadata(): 'Chromatogram'<br ALIGN="LEFT"/>with_peaks(peaks: List[Peak]): 'Chromatogram'<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"src.chromatographicpeakpicking.analyzers.chromatogram_analyzer.ChromatogramAnalyzer" [color="black", fontcolor="black", label=<{ChromatogramAnalyzer|config<br ALIGN="LEFT"/>global_config<br ALIGN="LEFT"/>logger : NoneType, RootLogger<br ALIGN="LEFT"/>|analyze_chromatogram(chrom: Chromatogram): Chromatogram<br ALIGN="LEFT"/>configure(config: ChromatogramAnalyzerConfig): ValidationResult<br ALIGN="LEFT"/>get_metadata(): ConfigMetadata<br ALIGN="LEFT"/>validate_config(config: ChromatogramAnalyzerConfig): ValidationResult<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"src.chromatographicpeakpicking.configurations.chromatogram_analyzer_config.ChromatogramAnalyzerConfig" [color="black", fontcolor="black", label=<{ChromatogramAnalyzerConfig|baseline_percentile : float<br ALIGN="LEFT"/>drift_window : int<br ALIGN="LEFT"/>edge_exclusion : float<br ALIGN="LEFT"/>max_noise_variance : float<br ALIGN="LEFT"/>max_region_gap : int<br ALIGN="LEFT"/>min_region_width : int<br ALIGN="LEFT"/>min_regions_required : int<br ALIGN="LEFT"/>min_window_points : int<br ALIGN="LEFT"/>noise_percentile : float<br ALIGN="LEFT"/>outlier_threshold : float<br ALIGN="LEFT"/>smoothing_window : int<br ALIGN="LEFT"/>variation_threshold : float<br ALIGN="LEFT"/>window_overlap : float<br ALIGN="LEFT"/>window_width : int<br ALIGN="LEFT"/>|}>, shape="record", style="solid"];
"src.chromatographicpeakpicking.analyzers.chromatogram_analyzer.ChromatogramAnalyzerConfig" [color="black", fontcolor="black", label=<{ChromatogramAnalyzerConfig|baseline_percentile : float<br ALIGN="LEFT"/>drift_window : int<br ALIGN="LEFT"/>edge_exclusion : float<br ALIGN="LEFT"/>max_noise_variance : float<br ALIGN="LEFT"/>max_region_gap : int<br ALIGN="LEFT"/>min_region_width : int<br ALIGN="LEFT"/>min_regions_required : int<br ALIGN="LEFT"/>min_window_points : int<br ALIGN="LEFT"/>noise_percentile : float<br ALIGN="LEFT"/>outlier_threshold : float<br ALIGN="LEFT"/>smoothing_window : int<br ALIGN="LEFT"/>variation_threshold : float<br ALIGN="LEFT"/>window_overlap : float<br ALIGN="LEFT"/>window_width : int<br ALIGN="LEFT"/>|}>, shape="record", style="solid"];
"src.chromatographicpeakpicking.metrics.chromatogram_metrics.ChromatogramMetrics" [color="black", fontcolor="black", label=<{ChromatogramMetrics|metrics : Dict[str, float]<br ALIGN="LEFT"/>|get_all_metrics(): Dict[str, float]<br ALIGN="LEFT"/>get_metric(metric_name: str): Optional[float]<br ALIGN="LEFT"/>set_metric(metric_name: str, value: float): None<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"src.chromatographicpeakpicking.infrastructure.metrics.chromatogram_metrics.ChromatogramMetrics" [color="black", fontcolor="black", label=<{ChromatogramMetrics|metrics : Dict[str, Any]<br ALIGN="LEFT"/>|get_all_metrics(): Dict[str, Any]<br ALIGN="LEFT"/>get_metric(key: str): Any<br ALIGN="LEFT"/>set_metric(key: str, value: Any)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"src.chromatographicpeakpicking.infrastructure.persistence.chromatogram_repository.ChromatogramRepository" [color="black", fontcolor="black", label=<{ChromatogramRepository|chromatograms : dict<br ALIGN="LEFT"/>|delete(chromatogram_id)<br ALIGN="LEFT"/>get(chromatogram_id)<br ALIGN="LEFT"/>get_all()<br ALIGN="LEFT"/>save(chromatogram)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"src.chromatographicpeakpicking.visualizers.chromatogram_visualizer.ChromatogramVisualizer" [color="black", fontcolor="black", label=<{ChromatogramVisualizer|config<br ALIGN="LEFT"/>|visualize(chrom: Chromatogram): Figure<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"src.chromatographicpeakpicking.configurations.chromatogram_visualizer_config.ChromatogramVisualizerConfig" [color="black", fontcolor="black", label=<{ChromatogramVisualizerConfig|rcParamas : dict<br ALIGN="LEFT"/>|}>, shape="record", style="solid"];
"src.chromatographicpeakpicking.peak_selection.classic_chrome.ClassicChrome" [color="black", fontcolor="black", label=<{ClassicChrome|config<br ALIGN="LEFT"/>|pick_peaks(chromatograms: Union[List[Chromatogram], Chromatogram]): Union[List[Chromatogram], Chromatogram]<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"src.chromatographicpeakpicking.configurations.classic_chrome_config.ClassicChromeConfig" [color="black", fontcolor="black", label=<{ClassicChromeConfig|min_peak_distance : int<br ALIGN="LEFT"/>min_peak_height : float<br ALIGN="LEFT"/>minor_peak_height_factor : float<br ALIGN="LEFT"/>minor_peak_prominence_factor : float<br ALIGN="LEFT"/>peak_prominence_factor : float<br ALIGN="LEFT"/>|}>, shape="record", style="solid"];
"src.chromatographicpeakpicking.config.config_manager.ConfigManager" [color="black", fontcolor="black", label=<{ConfigManager|components : Dict[str, Configurable]<br ALIGN="LEFT"/>|configure_component(name: str, config: BaseConfig): ValidationResult<br ALIGN="LEFT"/>get_component_metadata(name: str)<br ALIGN="LEFT"/>register_component(name: str, component: Configurable)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"src.chromatographicpeakpicking.core.types.config.ConfigMetadata" [color="black", fontcolor="black", label=<{ConfigMetadata|defaults : Dict[str, Any]<br ALIGN="LEFT"/>description : str<br ALIGN="LEFT"/>name : str<br ALIGN="LEFT"/>schema : Dict[str, Any]<br ALIGN="LEFT"/>validation_level<br ALIGN="LEFT"/>version : str<br ALIGN="LEFT"/>|}>, shape="record", style="solid"];
"src.chromatographicpeakpicking.core.types.config.ConfigValidation" [color="black", fontcolor="black", label=<{ConfigValidation|name<br ALIGN="LEFT"/>|}>, shape="record", style="solid"];
"src.chromatographicpeakpicking.core.protocols.configurable.Configurable" [color="black", fontcolor="black", label=<{Configurable|<br ALIGN="LEFT"/>|configure(config: T): ValidationResult<br ALIGN="LEFT"/>get_metadata(): ConfigMetadata<br ALIGN="LEFT"/>validate_config(config: T): ValidationResult<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"src.chromatographicpeakpicking.core.types.errors.ConfigurationError" [color="black", fontcolor="red", label=<{ConfigurationError|<br ALIGN="LEFT"/>|}>, shape="record", style="solid"];
"src.chromatographicpeakpicking.core.factories.corrector_factory.CorrectorFactory" [color="black", fontcolor="black", label=<{CorrectorFactory|<br ALIGN="LEFT"/>|create(name: str): BaselineCorrector<br ALIGN="LEFT"/>register(name: str, corrector_class: Type[BaselineCorrector]): None<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"src.chromatographicpeakpicking.core.factories.detector_factory.DetectorFactory" [color="black", fontcolor="black", label=<{DetectorFactory|<br ALIGN="LEFT"/>|create(name: str): PeakDetector<br ALIGN="LEFT"/>register(name: str, detector_class: Type[PeakDetector]): None<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"src.chromatographicpeakpicking.core.protocols.error_handler.ErrorCollection" [color="black", fontcolor="black", label=<{ErrorCollection|<br ALIGN="LEFT"/>|add_error(error: ProcessingError): None<br ALIGN="LEFT"/>clear(): None<br ALIGN="LEFT"/>get_errors(min_severity: Optional[ErrorSeverity]): List[ProcessingError]<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"src.chromatographicpeakpicking.core.protocols.error_handler.ErrorHandler" [color="black", fontcolor="black", label=<{ErrorHandler|<br ALIGN="LEFT"/>|handle_error(error: ProcessingError): bool<br ALIGN="LEFT"/><I>set_severity_threshold</I>(threshold: ErrorSeverity): None<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"src.chromatographicpeakpicking.core.types.errors.ErrorSeverity" [color="black", fontcolor="black", label=<{ErrorSeverity|name<br ALIGN="LEFT"/>|}>, shape="record", style="solid"];
"src.chromatographicpeakpicking.io.formats.excel_format.ExcelFormatHandler" [color="black", fontcolor="black", label=<{ExcelFormatHandler|<br ALIGN="LEFT"/>|read(path: Path): Dict[str, Any]<br ALIGN="LEFT"/>validate(path: Path): bool<br ALIGN="LEFT"/>write(data: Dict[str, Any], path: Path): None<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"src.chromatographicpeakpicking.io.formats.format_handler.FormatHandler" [color="black", fontcolor="black", label=<{FormatHandler|<br ALIGN="LEFT"/>|<I>read</I>(path: Path): Dict[str, Any]<br ALIGN="LEFT"/><I>validate</I>(path: Path): bool<br ALIGN="LEFT"/><I>write</I>(data: Dict[str, Any], path: Path): None<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"src.chromatographicpeakpicking.configurations.global_config.GlobalConfig" [color="black", fontcolor="black", label=<{GlobalConfig|debug : bool<br ALIGN="LEFT"/>|}>, shape="record", style="solid"];
"src.chromatographicpeakpicking.config.global_config.GlobalConfig" [color="black", fontcolor="black", label=<{GlobalConfig|debug : bool<br ALIGN="LEFT"/>|}>, shape="record", style="solid"];
"src.chromatographicpeakpicking.peak_selection.hierarchical_sgppm.HierarchicalSGPPM" [color="black", fontcolor="black", label=<{HierarchicalSGPPM|config<br ALIGN="LEFT"/>debug : bool<br ALIGN="LEFT"/>|pick_peaks(chromatograms: Union[List[Chromatogram], Chromatogram]): Union[List[Chromatogram], Chromatogram]<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"src.chromatographicpeakpicking.core.hierarchy.Hierarchy" [color="black", fontcolor="black", label=<{Hierarchy|ancestors : Dict[Tuple[BuildingBlock, ...], Set[Tuple[BuildingBlock, ...]]]<br ALIGN="LEFT"/>descendants : Dict[Tuple[BuildingBlock, ...], Set[Tuple[BuildingBlock, ...]]]<br ALIGN="LEFT"/>global_config<br ALIGN="LEFT"/>levels : Dict[int, Set[Tuple[BuildingBlock, ...]]]<br ALIGN="LEFT"/>null_element<br ALIGN="LEFT"/>sequence_values : Dict[Tuple[BuildingBlock, ...], V]<br ALIGN="LEFT"/>|add_sequence(sequence: Tuple[BuildingBlock, ...]): None<br ALIGN="LEFT"/>add_sequences(sequences: List[Tuple[BuildingBlock, ...]]): None<br ALIGN="LEFT"/>count_non_null(sequence: Tuple[BuildingBlock, ...]): int<br ALIGN="LEFT"/>generate_all_descendants(sequence: Tuple[BuildingBlock, ...]): List[Tuple[BuildingBlock, ...]]<br ALIGN="LEFT"/>generate_descendants_with_k_elements(sequence: Tuple[BuildingBlock, ...], k: int): Set[Tuple[BuildingBlock, ...]]<br ALIGN="LEFT"/>get_ancestors(sequence: Tuple[BuildingBlock, ...]): Set[Tuple[BuildingBlock, ...]]<br ALIGN="LEFT"/>get_descendants(sequence: Tuple[BuildingBlock, ...]): Set[Tuple[BuildingBlock, ...]]<br ALIGN="LEFT"/>get_direct_descendants(sequence: Tuple[BuildingBlock, ...]): Set[Tuple[BuildingBlock, ...]]<br ALIGN="LEFT"/>get_level(sequence: Tuple[BuildingBlock, ...]): int<br ALIGN="LEFT"/>get_sequence_value(sequence: Tuple[BuildingBlock, ...]): Optional[V]<br ALIGN="LEFT"/>get_sequences_by_level(level: int): Set[Tuple[BuildingBlock, ...]]<br ALIGN="LEFT"/>set_sequence_value(sequence: Tuple[BuildingBlock, ...], value: V): None<br ALIGN="LEFT"/>set_sequence_values(values: Dict[Tuple[BuildingBlock, ...], V]): None<br ALIGN="LEFT"/>visualize_hierarchy(figsize, node_size, with_values: bool, save_path: Optional[str], color_scheme: Optional[Dict[int, str]]): None<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"src.chromatographicpeakpicking.peak_selection.Ipeak_picker.IPeakPicker" [color="black", fontcolor="black", label=<{IPeakPicker|config : ConfigT<br ALIGN="LEFT"/>|<I>pick_peaks</I>(chromatograms: Union[List[Chromatogram], Chromatogram]): Union[List[Chromatogram], Chromatogram]<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"src.chromatographicpeakpicking.visualizers.image_type.ImageType" [color="black", fontcolor="black", label=<{ImageType|name<br ALIGN="LEFT"/>|}>, shape="record", style="solid"];
"src.chromatographicpeakpicking.core.protocols.observable.Observable" [color="black", fontcolor="black", label=<{Observable|<br ALIGN="LEFT"/>|add_observer(observer: Observer): None<br ALIGN="LEFT"/>notify_observers(event: AnalysisEvent): None<br ALIGN="LEFT"/>remove_observer(observer: Observer): None<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"src.chromatographicpeakpicking.core.protocols.observable.Observer" [color="black", fontcolor="black", label=<{Observer|<br ALIGN="LEFT"/>|update(event: AnalysisEvent): None<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"src.chromatographicpeakpicking.core.domain.peak.Peak" [color="black", fontcolor="black", label=<{Peak|apex_intensity : float<br ALIGN="LEFT"/>apex_time : float<br ALIGN="LEFT"/>area : float<br ALIGN="LEFT"/>asymmetry_factor : Optional[float]<br ALIGN="LEFT"/>baseline : Optional[np.ndarray]<br ALIGN="LEFT"/>end_time : float<br ALIGN="LEFT"/>gaussian_params : Optional[Dict[str, float]]<br ALIGN="LEFT"/>height : float<br ALIGN="LEFT"/>id : str<br ALIGN="LEFT"/>metadata : Dict[str, Any]<br ALIGN="LEFT"/>peak_capacity : Optional[float]<br ALIGN="LEFT"/>raw_intensities : Optional[np.ndarray]<br ALIGN="LEFT"/>raw_times : Optional[np.ndarray]<br ALIGN="LEFT"/>resolution : Optional[float]<br ALIGN="LEFT"/>retention_time<br ALIGN="LEFT"/>signal_to_noise : Optional[float]<br ALIGN="LEFT"/>start_time : float<br ALIGN="LEFT"/>symmetry<br ALIGN="LEFT"/>width<br ALIGN="LEFT"/>width_at_half_height : Optional[float]<br ALIGN="LEFT"/>|get_gaussian_fit(): Optional[Dict[str, float]]<br ALIGN="LEFT"/>with_gaussian_fit(params: Dict[str, float]): 'Peak'<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"src.chromatographicpeakpicking.analysis.peak.peak_analyzer.PeakAnalysisResult" [color="black", fontcolor="black", label=<{PeakAnalysisResult|fit_params : Dict[str, float]<br ALIGN="LEFT"/>peak<br ALIGN="LEFT"/>quality_metrics : Dict[str, float]<br ALIGN="LEFT"/>|}>, shape="record", style="solid"];
"src.chromatographicpeakpicking.analyzers.peak_analyzer.PeakAnalyzer" [color="black", fontcolor="black", label=<{PeakAnalyzer|config<br ALIGN="LEFT"/>|analyze_peak(peak: Peak, chromatogram: Chromatogram): Peak<br ALIGN="LEFT"/>configure(config: PeakAnalyzerConfig): ValidationResult<br ALIGN="LEFT"/>get_metadata(): ConfigMetadata<br ALIGN="LEFT"/>validate_config(config: PeakAnalyzerConfig): ValidationResult<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"src.chromatographicpeakpicking.analysis.peak.peak_analyzer.PeakAnalyzer" [color="black", fontcolor="black", label=<{PeakAnalyzer|intensities : ndarray<br ALIGN="LEFT"/>time_points : ndarray<br ALIGN="LEFT"/>|analyze(data: Peak): AnalysisResult[PeakAnalysisResult]<br ALIGN="LEFT"/>validate(data: Peak): bool<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"src.chromatographicpeakpicking.analyzers.peak_analyzer.PeakAnalyzerConfig" [color="black", fontcolor="black", label=<{PeakAnalyzerConfig|<br ALIGN="LEFT"/>|}>, shape="record", style="solid"];
"src.chromatographicpeakpicking.analysis.chromatogram.peak_detector.PeakDetectionResult" [color="black", fontcolor="black", label=<{PeakDetectionResult|metrics : Dict[str, float]<br ALIGN="LEFT"/>peaks : List[Peak]<br ALIGN="LEFT"/>|}>, shape="record", style="solid"];
"src.chromatographicpeakpicking.core.protocols.detectable.PeakDetector" [color="black", fontcolor="black", label=<{PeakDetector|<br ALIGN="LEFT"/>|detect(chromatogram: Chromatogram): List[Peak]<br ALIGN="LEFT"/>validate(chromatogram: Chromatogram): None<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"src.chromatographicpeakpicking.analysis.chromatogram.peak_detector.PeakDetector" [color="black", fontcolor="black", label=<{PeakDetector|height_threshold : float<br ALIGN="LEFT"/>prominence_threshold : float<br ALIGN="LEFT"/>width_threshold : float<br ALIGN="LEFT"/>|analyze(data: Chromatogram): AnalysisResult[PeakDetectionResult]<br ALIGN="LEFT"/>validate(data: Chromatogram): bool<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"src.chromatographicpeakpicking.peak_selection.peak_finder.PeakFinder" [color="black", fontcolor="black", label=<{PeakFinder|config<br ALIGN="LEFT"/>global_config<br ALIGN="LEFT"/>logger : NoneType, RootLogger<br ALIGN="LEFT"/>|find_peaks(chrom: Chromatogram): Chromatogram<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"src.chromatographicpeakpicking.configurations.peak_finder_config.PeakFinderConfig" [color="black", fontcolor="black", label=<{PeakFinderConfig|max_roughness_factor : float<br ALIGN="LEFT"/>max_snr_factor : float<br ALIGN="LEFT"/>max_window_roughness_factor : float<br ALIGN="LEFT"/>min_prominence_ratio : float<br ALIGN="LEFT"/>min_roughness_factor : float<br ALIGN="LEFT"/>min_snr_factor : float<br ALIGN="LEFT"/>min_window_points : int<br ALIGN="LEFT"/>min_window_roughness_factor : float<br ALIGN="LEFT"/>noise_prominence_factor : float<br ALIGN="LEFT"/>peak_separation_factor : float<br ALIGN="LEFT"/>relative_height : float<br ALIGN="LEFT"/>roughness_scale : float<br ALIGN="LEFT"/>snr_scale : float<br ALIGN="LEFT"/>window_roughness_scale : float<br ALIGN="LEFT"/>|}>, shape="record", style="solid"];
"src.chromatographicpeakpicking.analysis.peak.peak_interogrator.PeakIntegrationResult" [color="black", fontcolor="black", label=<{PeakIntegrationResult|area : float<br ALIGN="LEFT"/>baseline_corrected_area : float<br ALIGN="LEFT"/>metrics : Dict[str, float]<br ALIGN="LEFT"/>|}>, shape="record", style="solid"];
"src.chromatographicpeakpicking.analysis.peak.peak_interogrator.PeakIntegrator" [color="black", fontcolor="black", label=<{PeakIntegrator|intensities : ndarray<br ALIGN="LEFT"/>time_points : ndarray<br ALIGN="LEFT"/>window_size : int<br ALIGN="LEFT"/>|analyze(data: Peak): AnalysisResult[PeakIntegrationResult]<br ALIGN="LEFT"/>validate(data: Peak): bool<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"src.chromatographicpeakpicking.metrics.peak_metrics.PeakMetrics" [color="black", fontcolor="black", label=<{PeakMetrics|metrics : Dict[str, float]<br ALIGN="LEFT"/>|get_all_metrics(): Dict[str, float]<br ALIGN="LEFT"/>get_metric(metric_name: str): Optional[float]<br ALIGN="LEFT"/>set_metric(metric_name: str, value: float): None<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"src.chromatographicpeakpicking.infrastructure.persistence.peak_repository.PeakRepository" [color="black", fontcolor="black", label=<{PeakRepository|peaks : dict<br ALIGN="LEFT"/>|delete(peak_id)<br ALIGN="LEFT"/>get(peak_id)<br ALIGN="LEFT"/>get_all()<br ALIGN="LEFT"/>save(peak)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"src.chromatographicpeakpicking.core.protocols.selectable.PeakSelector" [color="black", fontcolor="black", label=<{PeakSelector|<br ALIGN="LEFT"/>|select(peaks: List[Peak]): List[Peak]<br ALIGN="LEFT"/>validate(peaks: List[Peak]): None<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"src.chromatographicpeakpicking.core.domain.peptide.Peptide" [color="black", fontcolor="black", label=<{Peptide|id : str<br ALIGN="LEFT"/>length<br ALIGN="LEFT"/>mass<br ALIGN="LEFT"/>metadata : Dict[str, Any]<br ALIGN="LEFT"/>peak_area : Optional[float]<br ALIGN="LEFT"/>peak_height : Optional[float]<br ALIGN="LEFT"/>retention_time : Optional[float]<br ALIGN="LEFT"/>sequence : List[BuildingBlock]<br ALIGN="LEFT"/>|get_building_block_at_position(position: int): BuildingBlock<br ALIGN="LEFT"/>get_sequence_string(separator: str): str<br ALIGN="LEFT"/>with_metadata(): 'Peptide'<br ALIGN="LEFT"/>with_peak_metrics(area: Optional[float], height: Optional[float]): 'Peptide'<br ALIGN="LEFT"/>with_retention_time(retention_time: float): 'Peptide'<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"src.chromatographicpeakpicking.infrastructure.logging.performance_logger.PerformanceLogger" [color="black", fontcolor="black", label=<{PerformanceLogger|operations : list<br ALIGN="LEFT"/>|get_average_duration(operation_name)<br ALIGN="LEFT"/>get_operation_history()<br ALIGN="LEFT"/>log_operation(operation_name, duration)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"src.chromatographicpeakpicking.infrastructure.metrics.performance_metrics.PerformanceMetrics" [color="black", fontcolor="black", label=<{PerformanceMetrics|metrics : dict<br ALIGN="LEFT"/>|end_operation(operation_name)<br ALIGN="LEFT"/>get_operation_stats(operation_name)<br ALIGN="LEFT"/>start_operation(operation_name)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"src.chromatographicpeakpicking.core.types.errors.PipelineError" [color="black", fontcolor="red", label=<{PipelineError|error<br ALIGN="LEFT"/>|}>, shape="record", style="solid"];
"src.chromatographicpeakpicking.core.factories.pipeline_factory.PipelineFactory" [color="black", fontcolor="black", label=<{PipelineFactory|<br ALIGN="LEFT"/>|create_pipeline(corrector: Optional[str], detector: Optional[str], selector: Optional[str]): 'AnalysisPipeline'<br ALIGN="LEFT"/>register_corrector(name: str, corrector: Type[BaselineCorrector]): None<br ALIGN="LEFT"/>register_detector(name: str, detector: Type[PeakDetector]): None<br ALIGN="LEFT"/>register_selector(name: str, selector: Type[PeakSelector]): None<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"src.chromatographicpeakpicking.pipeline.result.PipelineResult" [color="black", fontcolor="black", label=<{PipelineResult|final_output : T<br ALIGN="LEFT"/>stage_results : Dict[str, StageResult]<br ALIGN="LEFT"/>total_time : float<br ALIGN="LEFT"/>|}>, shape="record", style="solid"];
"src.chromatographicpeakpicking.pipeline.stage.PipelineStage" [color="black", fontcolor="black", label=<{PipelineStage|config<br ALIGN="LEFT"/>error_handler<br ALIGN="LEFT"/>name : str<br ALIGN="LEFT"/>|<I>execute</I>(input_data: Input): StageResult[Output]<br ALIGN="LEFT"/><I>validate</I>(input_data: Input): ValidationResult<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"src.chromatographicpeakpicking.core.types.errors.ProcessingError" [color="black", fontcolor="black", label=<{ProcessingError|details : Dict[str, Any]<br ALIGN="LEFT"/>message : str<br ALIGN="LEFT"/>severity<br ALIGN="LEFT"/>source : str<br ALIGN="LEFT"/>|}>, shape="record", style="solid"];
"src.chromatographicpeakpicking.io.protocols.reader.Reader" [color="black", fontcolor="black", label=<{Reader|<br ALIGN="LEFT"/>|<I>read</I>(source: Path): T<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"src.chromatographicpeakpicking.infrastructure.caching.result_cache.ResultCache" [color="black", fontcolor="black", label=<{ResultCache|cache : dict<br ALIGN="LEFT"/>|clear()<br ALIGN="LEFT"/>get(key)<br ALIGN="LEFT"/>invalidate(key)<br ALIGN="LEFT"/>set(key, value)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"src.chromatographicpeakpicking.peak_selection.sgppm.SGPPM" [color="black", fontcolor="black", label=<{SGPPM|config<br ALIGN="LEFT"/>global_config<br ALIGN="LEFT"/>logger : NoneType, RootLogger<br ALIGN="LEFT"/>|pick_peaks(chromatograms: Union[List[Chromatogram], Chromatogram]): Union[List[Chromatogram], Chromatogram]<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"src.chromatographicpeakpicking.configurations.sgppm_config.SGPPMConfig" [color="black", fontcolor="black", label=<{SGPPMConfig|correction_method : str<br ALIGN="LEFT"/>fit_points : int<br ALIGN="LEFT"/>gaussian_residuals_threshold : float<br ALIGN="LEFT"/>height_threshold : float<br ALIGN="LEFT"/>min_distance_factor : float<br ALIGN="LEFT"/>noise_factor : float<br ALIGN="LEFT"/>peak_time_threshold : float<br ALIGN="LEFT"/>pick_rel_height : float<br ALIGN="LEFT"/>search_rel_height : float<br ALIGN="LEFT"/>stddev_threshold : float<br ALIGN="LEFT"/>symmetry_threshold : float<br ALIGN="LEFT"/>width_max : int<br ALIGN="LEFT"/>width_min : float<br ALIGN="LEFT"/>window_length : int<br ALIGN="LEFT"/>|}>, shape="record", style="solid"];
"src.chromatographicpeakpicking.analysis.baseline.swm.SWM" [color="black", fontcolor="black", label=<{SWM|config<br ALIGN="LEFT"/>|configure(config: SWMConfig): ValidationResult<br ALIGN="LEFT"/>correct(chromatogram: Chromatogram): Chromatogram<br ALIGN="LEFT"/>get_metadata(): ConfigMetadata<br ALIGN="LEFT"/>validate_config(config: SWMConfig): ValidationResult<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"src.chromatographicpeakpicking.configurations.swm_config.SWMConfig" [color="black", fontcolor="black", label=<{SWMConfig|padding_mode : str<br ALIGN="LEFT"/>window_length : int<br ALIGN="LEFT"/>|}>, shape="record", style="solid"];
"src.chromatographicpeakpicking.analysis.baseline.swm.SWMConfig" [color="black", fontcolor="black", label=<{SWMConfig|<br ALIGN="LEFT"/>|}>, shape="record", style="solid"];
"src.chromatographicpeakpicking.core.protocols.serializable.Serializable" [color="black", fontcolor="black", label=<{Serializable|<br ALIGN="LEFT"/>|from_dict(data: Dict[str, Any]): 'Serializable'<br ALIGN="LEFT"/>to_dict(): Dict[str, Any]<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"src.chromatographicpeakpicking.pipeline.result.StageResult" [color="black", fontcolor="black", label=<{StageResult|errors : List[ProcessingError]<br ALIGN="LEFT"/>execution_time : float<br ALIGN="LEFT"/>metadata : Dict[str, Any]<br ALIGN="LEFT"/>output : T<br ALIGN="LEFT"/>warnings : List[ProcessingError]<br ALIGN="LEFT"/>|}>, shape="record", style="solid"];
"src.chromatographicpeakpicking.parsers.tabular_data_parser.TabularDataParser" [color="black", fontcolor="black", label=<{TabularDataParser|config<br ALIGN="LEFT"/>|parse_data(input_path: str): DataFrame<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"src.chromatographicpeakpicking.configurations.tabular_data_parser_config.TabularDataParserConfig" [color="black", fontcolor="black", label=<{TabularDataParserConfig|building_block_columns : Dict[str, str]<br ALIGN="LEFT"/>common_name_column : str<br ALIGN="LEFT"/>excel_sheet : str<br ALIGN="LEFT"/>lid_column : str<br ALIGN="LEFT"/>lid_to_process : str<br ALIGN="LEFT"/>null_building_block : str<br ALIGN="LEFT"/>raw_data_column : str<br ALIGN="LEFT"/>scaffold_column : str<br ALIGN="LEFT"/>smiles_column : str<br ALIGN="LEFT"/>|}>, shape="record", style="solid"];
"src.chromatographicpeakpicking.core.protocols.validatable.Validatable" [color="black", fontcolor="black", label=<{Validatable|<br ALIGN="LEFT"/>|is_valid(): bool<br ALIGN="LEFT"/>validate(): List[ValidationError]<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"src.chromatographicpeakpicking.core.types.errors.ValidationError" [color="black", fontcolor="red", label=<{ValidationError|<br ALIGN="LEFT"/>|}>, shape="record", style="solid"];
"src.chromatographicpeakpicking.core.protocols.validatable.ValidationError" [color="black", fontcolor="black", label=<{ValidationError|code : Optional[str]<br ALIGN="LEFT"/>message : str<br ALIGN="LEFT"/>|}>, shape="record", style="solid"];
"src.chromatographicpeakpicking.core.types.validation.ValidationLevel" [color="black", fontcolor="black", label=<{ValidationLevel|name<br ALIGN="LEFT"/>|}>, shape="record", style="solid"];
"src.chromatographicpeakpicking.core.types.validation.ValidationMessage" [color="black", fontcolor="black", label=<{ValidationMessage|context : Dict[str, Any]<br ALIGN="LEFT"/>field : Optional[str]<br ALIGN="LEFT"/>level<br ALIGN="LEFT"/>message : str<br ALIGN="LEFT"/>|}>, shape="record", style="solid"];
"src.chromatographicpeakpicking.core.types.validation.ValidationResult" [color="black", fontcolor="black", label=<{ValidationResult|is_valid : bool<br ALIGN="LEFT"/>messages : List[ValidationMessage]<br ALIGN="LEFT"/>|has_errors(): bool<br ALIGN="LEFT"/>has_warnings(): bool<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"src.chromatographicpeakpicking.core.protocols.visualizable.Visualizable" [color="black", fontcolor="black", label=<{Visualizable|<br ALIGN="LEFT"/>|save(path: Path): None<br ALIGN="LEFT"/>visualize(data: Any): Any<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"src.chromatographicpeakpicking.io.protocols.writer.Writer" [color="black", fontcolor="black", label=<{Writer|<br ALIGN="LEFT"/>|<I>write</I>(data: T, destination: Path): None<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"src.chromatographicpeakpicking.analysis.baseline.aals.AALSConfig" -> "src.chromatographicpeakpicking.core.types.config.BaseConfig" [arrowhead="empty", arrowtail="none"];
"src.chromatographicpeakpicking.analysis.baseline.aals.AALSCorrector" -> "src.chromatographicpeakpicking.core.protocols.configurable.Configurable" [arrowhead="empty", arrowtail="none"];
"src.chromatographicpeakpicking.analysis.baseline.swm.SWM" -> "src.chromatographicpeakpicking.core.protocols.configurable.Configurable" [arrowhead="empty", arrowtail="none"];
"src.chromatographicpeakpicking.analysis.baseline.swm.SWMConfig" -> "src.chromatographicpeakpicking.core.types.config.BaseConfig" [arrowhead="empty", arrowtail="none"];
"src.chromatographicpeakpicking.analysis.chromatogram.baseline_analyzer.BaselineAnalyzer" -> "src.chromatographicpeakpicking.analysis.protocols.analyzer.Analyzer" [arrowhead="empty", arrowtail="none"];
"src.chromatographicpeakpicking.analysis.chromatogram.peak_detector.PeakDetector" -> "src.chromatographicpeakpicking.analysis.protocols.analyzer.Analyzer" [arrowhead="empty", arrowtail="none"];
"src.chromatographicpeakpicking.analysis.peak.peak_analyzer.PeakAnalyzer" -> "src.chromatographicpeakpicking.analysis.protocols.analyzer.Analyzer" [arrowhead="empty", arrowtail="none"];
"src.chromatographicpeakpicking.analysis.peak.peak_interogrator.PeakIntegrator" -> "src.chromatographicpeakpicking.analysis.protocols.analyzer.Analyzer" [arrowhead="empty", arrowtail="none"];
"src.chromatographicpeakpicking.analyzers.chromatogram_analyzer.ChromatogramAnalyzer" -> "src.chromatographicpeakpicking.core.protocols.configurable.Configurable" [arrowhead="empty", arrowtail="none"];
"src.chromatographicpeakpicking.analyzers.chromatogram_analyzer.ChromatogramAnalyzerConfig" -> "src.chromatographicpeakpicking.core.types.config.BaseConfig" [arrowhead="empty", arrowtail="none"];
"src.chromatographicpeakpicking.analyzers.peak_analyzer.PeakAnalyzer" -> "src.chromatographicpeakpicking.core.protocols.configurable.Configurable" [arrowhead="empty", arrowtail="none"];
"src.chromatographicpeakpicking.analyzers.peak_analyzer.PeakAnalyzerConfig" -> "src.chromatographicpeakpicking.core.types.config.BaseConfig" [arrowhead="empty", arrowtail="none"];
"src.chromatographicpeakpicking.core.types.errors.ConfigurationError" -> "src.chromatographicpeakpicking.core.types.errors.PipelineError" [arrowhead="empty", arrowtail="none"];
"src.chromatographicpeakpicking.core.types.errors.ValidationError" -> "src.chromatographicpeakpicking.core.types.errors.PipelineError" [arrowhead="empty", arrowtail="none"];
"src.chromatographicpeakpicking.infrastructure.persistence.chromatogram_repository.ChromatogramRepository" -> "src.chromatographicpeakpicking.infrastructure.persistence.base_repository.BaseRepository" [arrowhead="empty", arrowtail="none"];
"src.chromatographicpeakpicking.infrastructure.persistence.peak_repository.PeakRepository" -> "src.chromatographicpeakpicking.infrastructure.persistence.base_repository.BaseRepository" [arrowhead="empty", arrowtail="none"];
"src.chromatographicpeakpicking.io.formats.csv_format.CSVFormatHandler" -> "src.chromatographicpeakpicking.io.formats.format_handler.FormatHandler" [arrowhead="empty", arrowtail="none"];
"src.chromatographicpeakpicking.io.formats.excel_format.ExcelFormatHandler" -> "src.chromatographicpeakpicking.io.formats.format_handler.FormatHandler" [arrowhead="empty", arrowtail="none"];
"src.chromatographicpeakpicking.peak_selection.hierarchical_sgppm.HierarchicalSGPPM" -> "src.chromatographicpeakpicking.peak_selection.sgppm.SGPPM" [arrowhead="empty", arrowtail="none"];
"src.chromatographicpeakpicking.analysis.baseline.aals.AALSConfig" -> "src.chromatographicpeakpicking.analysis.baseline.aals.AALSCorrector" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="config", style="solid"];
"src.chromatographicpeakpicking.analysis.baseline.swm.SWMConfig" -> "src.chromatographicpeakpicking.analysis.baseline.swm.SWM" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="config", style="solid"];
"src.chromatographicpeakpicking.analyzers.chromatogram_analyzer.ChromatogramAnalyzerConfig" -> "src.chromatographicpeakpicking.analyzers.chromatogram_analyzer.ChromatogramAnalyzer" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="config", style="solid"];
"src.chromatographicpeakpicking.analyzers.peak_analyzer.PeakAnalyzerConfig" -> "src.chromatographicpeakpicking.analyzers.peak_analyzer.PeakAnalyzer" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="config", style="solid"];
"src.chromatographicpeakpicking.config.global_config.GlobalConfig" -> "src.chromatographicpeakpicking.analyzers.chromatogram_analyzer.ChromatogramAnalyzer" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="global_config", style="solid"];
"src.chromatographicpeakpicking.core.types.config.ConfigMetadata" -> "src.chromatographicpeakpicking.core.types.config.BaseConfig" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="metadata", style="solid"];
"src.chromatographicpeakpicking.core.types.config.ConfigValidation" -> "src.chromatographicpeakpicking.core.types.config.ConfigMetadata" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="validation_level", style="solid"];
"src.chromatographicpeakpicking.core.types.errors.ErrorSeverity" -> "src.chromatographicpeakpicking.core.types.errors.ProcessingError" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="severity", style="solid"];
"src.chromatographicpeakpicking.core.types.validation.ValidationLevel" -> "src.chromatographicpeakpicking.core.types.validation.ValidationMessage" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="level", style="solid"];
"src.chromatographicpeakpicking.core.domain.peak.Peak" -> "src.chromatographicpeakpicking.analysis.peak.peak_analyzer.PeakAnalysisResult" [arrowhead="odiamond", arrowtail="none", fontcolor="green", label="peak", style="solid"];
"src.chromatographicpeakpicking.core.protocols.error_handler.ErrorHandler" -> "src.chromatographicpeakpicking.pipeline.stage.PipelineStage" [arrowhead="odiamond", arrowtail="none", fontcolor="green", label="_error_handler", style="solid"];
"src.chromatographicpeakpicking.core.types.errors.ProcessingError" -> "src.chromatographicpeakpicking.core.types.errors.PipelineError" [arrowhead="odiamond", arrowtail="none", fontcolor="green", label="error", style="solid"];
}
