digraph "classes_core" {
rankdir=BT
charset="utf-8"
"src.chromatographicpeakpicking.core.protocols.observable.AnalysisEvent" [color="black", fontcolor="black", label=<{AnalysisEvent|message : str<br ALIGN="LEFT"/>progress : float<br ALIGN="LEFT"/>stage : str<br ALIGN="LEFT"/>|}>, shape="record", style="solid"];
"src.chromatographicpeakpicking.core.protocols.analyzable.Analyzable" [color="black", fontcolor="black", label=<{Analyzable|<br ALIGN="LEFT"/>|analyze(data: Any): Any<br ALIGN="LEFT"/>validate(data: Any): bool<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"src.chromatographicpeakpicking.core.factories.analyzer_factory.AnalyzerFactory" [color="black", fontcolor="black", label=<{AnalyzerFactory|<br ALIGN="LEFT"/>|create(name: str): Analyzable<br ALIGN="LEFT"/>register(name: str, analyzer_class: Type[Analyzable]): None<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"src.chromatographicpeakpicking.core.types.config.BaseConfig" [color="black", fontcolor="black", label=<{BaseConfig|metadata<br ALIGN="LEFT"/>parameters : Dict[str, Any]<br ALIGN="LEFT"/>|}>, shape="record", style="solid"];
"src.chromatographicpeakpicking.core.protocols.correctable.BaselineCorrector" [color="black", fontcolor="black", label=<{BaselineCorrector|<br ALIGN="LEFT"/>|correct(chromatogram: Chromatogram): Chromatogram<br ALIGN="LEFT"/>validate(chromatogram: Chromatogram): None<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"src.chromatographicpeakpicking.core.domain.building_block.BuildingBlock" [color="black", fontcolor="black", label=<{BuildingBlock|formula : Optional[str]<br ALIGN="LEFT"/>id : str<br ALIGN="LEFT"/>mass : float<br ALIGN="LEFT"/>metadata : Dict[str, Any]<br ALIGN="LEFT"/>name : str<br ALIGN="LEFT"/>properties : Optional[Dict[str, Any]]<br ALIGN="LEFT"/>smiles : Optional[str]<br ALIGN="LEFT"/>|with_metadata(): 'BuildingBlock'<br ALIGN="LEFT"/>with_properties(): 'BuildingBlock'<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"src.chromatographicpeakpicking.core.domain.chromatogram.Chromatogram" [color="black", fontcolor="black", label=<{Chromatogram|baseline : Optional[np.ndarray]<br ALIGN="LEFT"/>building_blocks : List[BuildingBlock]<br ALIGN="LEFT"/>duration<br ALIGN="LEFT"/>id : str<br ALIGN="LEFT"/>intensity : ndarray<br ALIGN="LEFT"/>length<br ALIGN="LEFT"/>metadata : Dict[str, Any]<br ALIGN="LEFT"/>metrics : Optional[Any]<br ALIGN="LEFT"/>noise_level : Optional[float]<br ALIGN="LEFT"/>num_peaks<br ALIGN="LEFT"/>peaks : List[Peak]<br ALIGN="LEFT"/>picked_peak : Optional[Peak]<br ALIGN="LEFT"/>search_mask : Optional[np.ndarray]<br ALIGN="LEFT"/>time : ndarray<br ALIGN="LEFT"/>y_corrected : Optional[np.ndarray]<br ALIGN="LEFT"/>|get_corrected_intensity(): np.ndarray<br ALIGN="LEFT"/>get_intensity_range(): tuple[float, float]<br ALIGN="LEFT"/>get_peaks_in_range(start_time: float, end_time: float): List[Peak]<br ALIGN="LEFT"/>get_signal_at_time(t: float): Optional[float]<br ALIGN="LEFT"/>get_time_range(): tuple[float, float]<br ALIGN="LEFT"/>normalize(method: str): 'Chromatogram'<br ALIGN="LEFT"/>resample(num_points: int): 'Chromatogram'<br ALIGN="LEFT"/>slice(start_time: float, end_time: float): 'Chromatogram'<br ALIGN="LEFT"/>smooth(window_length: int, polyorder: int): 'Chromatogram'<br ALIGN="LEFT"/>with_baseline(baseline: np.ndarray): 'Chromatogram'<br ALIGN="LEFT"/>with_building_blocks(blocks: List[BuildingBlock]): 'Chromatogram'<br ALIGN="LEFT"/>with_metadata(): 'Chromatogram'<br ALIGN="LEFT"/>with_peaks(peaks: List[Peak]): 'Chromatogram'<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"src.chromatographicpeakpicking.core.types.config.ConfigMetadata" [color="black", fontcolor="black", label=<{ConfigMetadata|defaults : Dict[str, Any]<br ALIGN="LEFT"/>description : str<br ALIGN="LEFT"/>name : str<br ALIGN="LEFT"/>schema : Dict[str, Any]<br ALIGN="LEFT"/>validation_level<br ALIGN="LEFT"/>version : str<br ALIGN="LEFT"/>|}>, shape="record", style="solid"];
"src.chromatographicpeakpicking.core.types.config.ConfigValidation" [color="black", fontcolor="black", label=<{ConfigValidation|name<br ALIGN="LEFT"/>|}>, shape="record", style="solid"];
"src.chromatographicpeakpicking.core.protocols.configurable.Configurable" [color="black", fontcolor="black", label=<{Configurable|<br ALIGN="LEFT"/>|configure(config: T): ValidationResult<br ALIGN="LEFT"/>get_metadata(): ConfigMetadata<br ALIGN="LEFT"/>validate_config(config: T): ValidationResult<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"src.chromatographicpeakpicking.core.types.errors.ConfigurationError" [color="black", fontcolor="red", label=<{ConfigurationError|<br ALIGN="LEFT"/>|}>, shape="record", style="solid"];
"src.chromatographicpeakpicking.core.factories.corrector_factory.CorrectorFactory" [color="black", fontcolor="black", label=<{CorrectorFactory|<br ALIGN="LEFT"/>|create(name: str): BaselineCorrector<br ALIGN="LEFT"/>register(name: str, corrector_class: Type[BaselineCorrector]): None<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"src.chromatographicpeakpicking.core.factories.detector_factory.DetectorFactory" [color="black", fontcolor="black", label=<{DetectorFactory|<br ALIGN="LEFT"/>|create(name: str): PeakDetector<br ALIGN="LEFT"/>register(name: str, detector_class: Type[PeakDetector]): None<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"src.chromatographicpeakpicking.core.protocols.error_handler.ErrorCollection" [color="black", fontcolor="black", label=<{ErrorCollection|<br ALIGN="LEFT"/>|add_error(error: ProcessingError): None<br ALIGN="LEFT"/>clear(): None<br ALIGN="LEFT"/>get_errors(min_severity: Optional[ErrorSeverity]): List[ProcessingError]<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"src.chromatographicpeakpicking.core.protocols.error_handler.ErrorHandler" [color="black", fontcolor="black", label=<{ErrorHandler|<br ALIGN="LEFT"/>|handle_error(error: ProcessingError): bool<br ALIGN="LEFT"/><I>set_severity_threshold</I>(threshold: ErrorSeverity): None<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"src.chromatographicpeakpicking.core.types.errors.ErrorSeverity" [color="black", fontcolor="black", label=<{ErrorSeverity|name<br ALIGN="LEFT"/>|}>, shape="record", style="solid"];
"src.chromatographicpeakpicking.core.hierarchy.Hierarchy" [color="black", fontcolor="black", label=<{Hierarchy|ancestors : Dict[Tuple[BuildingBlock, ...], Set[Tuple[BuildingBlock, ...]]]<br ALIGN="LEFT"/>descendants : Dict[Tuple[BuildingBlock, ...], Set[Tuple[BuildingBlock, ...]]]<br ALIGN="LEFT"/>global_config<br ALIGN="LEFT"/>levels : Dict[int, Set[Tuple[BuildingBlock, ...]]]<br ALIGN="LEFT"/>null_element<br ALIGN="LEFT"/>sequence_values : Dict[Tuple[BuildingBlock, ...], V]<br ALIGN="LEFT"/>|add_sequence(sequence: Tuple[BuildingBlock, ...]): None<br ALIGN="LEFT"/>add_sequences(sequences: List[Tuple[BuildingBlock, ...]]): None<br ALIGN="LEFT"/>count_non_null(sequence: Tuple[BuildingBlock, ...]): int<br ALIGN="LEFT"/>generate_all_descendants(sequence: Tuple[BuildingBlock, ...]): List[Tuple[BuildingBlock, ...]]<br ALIGN="LEFT"/>generate_descendants_with_k_elements(sequence: Tuple[BuildingBlock, ...], k: int): Set[Tuple[BuildingBlock, ...]]<br ALIGN="LEFT"/>get_ancestors(sequence: Tuple[BuildingBlock, ...]): Set[Tuple[BuildingBlock, ...]]<br ALIGN="LEFT"/>get_descendants(sequence: Tuple[BuildingBlock, ...]): Set[Tuple[BuildingBlock, ...]]<br ALIGN="LEFT"/>get_direct_descendants(sequence: Tuple[BuildingBlock, ...]): Set[Tuple[BuildingBlock, ...]]<br ALIGN="LEFT"/>get_level(sequence: Tuple[BuildingBlock, ...]): int<br ALIGN="LEFT"/>get_sequence_value(sequence: Tuple[BuildingBlock, ...]): Optional[V]<br ALIGN="LEFT"/>get_sequences_by_level(level: int): Set[Tuple[BuildingBlock, ...]]<br ALIGN="LEFT"/>set_sequence_value(sequence: Tuple[BuildingBlock, ...], value: V): None<br ALIGN="LEFT"/>set_sequence_values(values: Dict[Tuple[BuildingBlock, ...], V]): None<br ALIGN="LEFT"/>visualize_hierarchy(figsize, node_size, with_values: bool, save_path: Optional[str], color_scheme: Optional[Dict[int, str]]): None<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"src.chromatographicpeakpicking.core.protocols.observable.Observable" [color="black", fontcolor="black", label=<{Observable|<br ALIGN="LEFT"/>|add_observer(observer: Observer): None<br ALIGN="LEFT"/>notify_observers(event: AnalysisEvent): None<br ALIGN="LEFT"/>remove_observer(observer: Observer): None<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"src.chromatographicpeakpicking.core.protocols.observable.Observer" [color="black", fontcolor="black", label=<{Observer|<br ALIGN="LEFT"/>|update(event: AnalysisEvent): None<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"src.chromatographicpeakpicking.core.domain.peak.Peak" [color="black", fontcolor="black", label=<{Peak|apex_intensity : float<br ALIGN="LEFT"/>apex_time : float<br ALIGN="LEFT"/>area : float<br ALIGN="LEFT"/>asymmetry_factor : Optional[float]<br ALIGN="LEFT"/>baseline : Optional[np.ndarray]<br ALIGN="LEFT"/>end_time : float<br ALIGN="LEFT"/>gaussian_params : Optional[Dict[str, float]]<br ALIGN="LEFT"/>height : float<br ALIGN="LEFT"/>id : str<br ALIGN="LEFT"/>metadata : Dict[str, Any]<br ALIGN="LEFT"/>peak_capacity : Optional[float]<br ALIGN="LEFT"/>raw_intensities : Optional[np.ndarray]<br ALIGN="LEFT"/>raw_times : Optional[np.ndarray]<br ALIGN="LEFT"/>resolution : Optional[float]<br ALIGN="LEFT"/>retention_time<br ALIGN="LEFT"/>signal_to_noise : Optional[float]<br ALIGN="LEFT"/>start_time : float<br ALIGN="LEFT"/>symmetry<br ALIGN="LEFT"/>width<br ALIGN="LEFT"/>width_at_half_height : Optional[float]<br ALIGN="LEFT"/>|get_gaussian_fit(): Optional[Dict[str, float]]<br ALIGN="LEFT"/>with_gaussian_fit(params: Dict[str, float]): 'Peak'<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"src.chromatographicpeakpicking.core.protocols.detectable.PeakDetector" [color="black", fontcolor="black", label=<{PeakDetector|<br ALIGN="LEFT"/>|detect(chromatogram: Chromatogram): List[Peak]<br ALIGN="LEFT"/>validate(chromatogram: Chromatogram): None<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"src.chromatographicpeakpicking.core.protocols.selectable.PeakSelector" [color="black", fontcolor="black", label=<{PeakSelector|<br ALIGN="LEFT"/>|select(peaks: List[Peak]): List[Peak]<br ALIGN="LEFT"/>validate(peaks: List[Peak]): None<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"src.chromatographicpeakpicking.core.domain.peptide.Peptide" [color="black", fontcolor="black", label=<{Peptide|id : str<br ALIGN="LEFT"/>length<br ALIGN="LEFT"/>mass<br ALIGN="LEFT"/>metadata : Dict[str, Any]<br ALIGN="LEFT"/>peak_area : Optional[float]<br ALIGN="LEFT"/>peak_height : Optional[float]<br ALIGN="LEFT"/>retention_time : Optional[float]<br ALIGN="LEFT"/>sequence : List[BuildingBlock]<br ALIGN="LEFT"/>|get_building_block_at_position(position: int): BuildingBlock<br ALIGN="LEFT"/>get_sequence_string(separator: str): str<br ALIGN="LEFT"/>with_metadata(): 'Peptide'<br ALIGN="LEFT"/>with_peak_metrics(area: Optional[float], height: Optional[float]): 'Peptide'<br ALIGN="LEFT"/>with_retention_time(retention_time: float): 'Peptide'<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"src.chromatographicpeakpicking.core.types.errors.PipelineError" [color="black", fontcolor="red", label=<{PipelineError|error<br ALIGN="LEFT"/>|}>, shape="record", style="solid"];
"src.chromatographicpeakpicking.core.factories.pipeline_factory.PipelineFactory" [color="black", fontcolor="black", label=<{PipelineFactory|<br ALIGN="LEFT"/>|create_pipeline(corrector: Optional[str], detector: Optional[str], selector: Optional[str]): 'AnalysisPipeline'<br ALIGN="LEFT"/>register_corrector(name: str, corrector: Type[BaselineCorrector]): None<br ALIGN="LEFT"/>register_detector(name: str, detector: Type[PeakDetector]): None<br ALIGN="LEFT"/>register_selector(name: str, selector: Type[PeakSelector]): None<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"src.chromatographicpeakpicking.core.types.errors.ProcessingError" [color="black", fontcolor="black", label=<{ProcessingError|details : Dict[str, Any]<br ALIGN="LEFT"/>message : str<br ALIGN="LEFT"/>severity<br ALIGN="LEFT"/>source : str<br ALIGN="LEFT"/>|}>, shape="record", style="solid"];
"src.chromatographicpeakpicking.core.protocols.serializable.Serializable" [color="black", fontcolor="black", label=<{Serializable|<br ALIGN="LEFT"/>|from_dict(data: Dict[str, Any]): 'Serializable'<br ALIGN="LEFT"/>to_dict(): Dict[str, Any]<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"src.chromatographicpeakpicking.core.protocols.validatable.Validatable" [color="black", fontcolor="black", label=<{Validatable|<br ALIGN="LEFT"/>|is_valid(): bool<br ALIGN="LEFT"/>validate(): List[ValidationError]<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"src.chromatographicpeakpicking.core.types.errors.ValidationError" [color="black", fontcolor="red", label=<{ValidationError|<br ALIGN="LEFT"/>|}>, shape="record", style="solid"];
"src.chromatographicpeakpicking.core.protocols.validatable.ValidationError" [color="black", fontcolor="black", label=<{ValidationError|code : Optional[str]<br ALIGN="LEFT"/>message : str<br ALIGN="LEFT"/>|}>, shape="record", style="solid"];
"src.chromatographicpeakpicking.core.types.validation.ValidationLevel" [color="black", fontcolor="black", label=<{ValidationLevel|name<br ALIGN="LEFT"/>|}>, shape="record", style="solid"];
"src.chromatographicpeakpicking.core.types.validation.ValidationMessage" [color="black", fontcolor="black", label=<{ValidationMessage|context : Dict[str, Any]<br ALIGN="LEFT"/>field : Optional[str]<br ALIGN="LEFT"/>level<br ALIGN="LEFT"/>message : str<br ALIGN="LEFT"/>|}>, shape="record", style="solid"];
"src.chromatographicpeakpicking.core.types.validation.ValidationResult" [color="black", fontcolor="black", label=<{ValidationResult|is_valid : bool<br ALIGN="LEFT"/>messages : List[ValidationMessage]<br ALIGN="LEFT"/>|has_errors(): bool<br ALIGN="LEFT"/>has_warnings(): bool<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"src.chromatographicpeakpicking.core.protocols.visualizable.Visualizable" [color="black", fontcolor="black", label=<{Visualizable|<br ALIGN="LEFT"/>|save(path: Path): None<br ALIGN="LEFT"/>visualize(data: Any): Any<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"src.chromatographicpeakpicking.core.types.errors.ConfigurationError" -> "src.chromatographicpeakpicking.core.types.errors.PipelineError" [arrowhead="empty", arrowtail="none"];
"src.chromatographicpeakpicking.core.types.errors.ValidationError" -> "src.chromatographicpeakpicking.core.types.errors.PipelineError" [arrowhead="empty", arrowtail="none"];
"src.chromatographicpeakpicking.core.types.config.ConfigMetadata" -> "src.chromatographicpeakpicking.core.types.config.BaseConfig" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="metadata", style="solid"];
"src.chromatographicpeakpicking.core.types.config.ConfigValidation" -> "src.chromatographicpeakpicking.core.types.config.ConfigMetadata" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="validation_level", style="solid"];
"src.chromatographicpeakpicking.core.types.errors.ErrorSeverity" -> "src.chromatographicpeakpicking.core.types.errors.ProcessingError" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="severity", style="solid"];
"src.chromatographicpeakpicking.core.types.validation.ValidationLevel" -> "src.chromatographicpeakpicking.core.types.validation.ValidationMessage" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="level", style="solid"];
"src.chromatographicpeakpicking.core.types.errors.ProcessingError" -> "src.chromatographicpeakpicking.core.types.errors.PipelineError" [arrowhead="odiamond", arrowtail="none", fontcolor="green", label="error", style="solid"];
}
